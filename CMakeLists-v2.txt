#
# Teem: Tools to process and visualize scientific data and images
# Copyright (C) 2009--2025  University of Chicago
# Copyright (C) 2005--2008  Gordon Kindlmann
# Copyright (C) 1998--2004  University of Utah
#
# This library is free software; you can redistribute it and/or modify it under the terms
# of the GNU Lesser General Public License (LGPL) as published by the Free Software
# Foundation; either version 2.1 of the License, or (at your option) any later version.
# The terms of redistributing and/or modifying this software also include exceptions to
# the LGPL that facilitate static linking.
#
# This library is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, see <https://www.gnu.org/licenses/>.
#

# Teem/CMakeLists.txt Version 10.98

# This CMakeLists.txt describes a Teem package that contains:
# (1) a library ("libteem" on unix) and
# (2) associated command-line tools (like "unu").

# Teem is itself made of component libraries (air, hest, biff, nrrd, etc.) but in CMake
# we do not compile these as libraries per se: they are merely containers for .c and .h
# files, which we compile to a single "monolithic" library. Teem also has a separate
# system of GNUmakefiles (re-written for Teem v2) which do build the finer-grained
# per-component libraries (libair.a, libhest.a, etc). These remain useful for Teem
# development, but there's no reason to complicate this CMakeLists.txt with describing
# those smaller libraries and their inter-dependencies.

###-------------------------------------------------------------------------------------
# Project setup: version, metadata, and language

# CMake Version 3.25 came out November 16, 2022
# https://www.kitware.com/cmake-3-25-0-available-for-download/
# why use 3.25: has nicer syntax for try_compile
cmake_minimum_required(VERSION 3.25)

# Teem version number (must match values in src/air/air.h)
set(Teem_VERSION_MAJOR 1)
set(Teem_VERSION_MINOR 12)
set(Teem_VERSION_PATCH 0)
set(Teem_VERSION_STRING ${Teem_VERSION_MAJOR}.${Teem_VERSION_MINOR}.${Teem_VERSION_PATCH})

project(Teem VERSION ${Teem_VERSION_STRING}
        DESCRIPTION "Teem libraries developed by Gordon Kindlmann et al."
        HOMEPAGE_URL "https://teem.sourceforge.net/"
        LANGUAGES C)

message(STATUS "


********************************************************************
** Please join the Teem-users discord https://discord.gg/xBBqZGXkF7
** to share how Teem works or does not work for you!
** For example, are these re-written CMakeLists.txt files working?
********************************************************************


")

###-------------------------------------------------------------------------------------
# Include helpers and module paths

# include(CTest) will create the BUILD_TESTING option, turn it ON, hook into CTest, and
# in turn include(CTestConfig.cmake). Most of which is fine, but we want to turn
# BUILD_TESTING OFF by default and give a better description
set(BUILD_TESTING OFF CACHE BOOL "Build Teem's *meagre* ctests")
include(CTest)

# https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html
include(GNUInstallDirs)      # sets CMAKE_INSTALL_*DIR variables
include(CMakeParseArguments) # for cmake_parse_arguments
include(CMakePrintHelpers)   # for debugging via cmake_print_variables(varname)

# CMake modules path (for e.g. CheckLibM.cmake)
set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/CMake")

###-------------------------------------------------------------------------------------
# Project options, including choosing dependencies
#  - canonical list of optional dependencies
#  - option() flags for enabling/disabling them

# Do we make a shared library?  BUILD_SHARED_LIBS has particular meaning to CMake
#   https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
#   https://gitlab.kitware.com/cmake/cmake/-/issues/25699
option(BUILD_SHARED_LIBS "Build a libteem shared library" ON)

# The canonical list of libraries that Teem can (optionally) depend on. Within this
# CMakeLists.txt file, each one is a "DEP" or dependency (however, FYI, within the
# GNUmakefiles, each is called an EXT or external).  Note: inter-dependency dependencies
# are known in the INTERFACE_LINK_LIBRARIES of each target.
set(_Teem_DEPS PNG ZLIB BZIP2 LEVMAR FFTW3 PTHREAD)

# docstrings of all dependencies, to avoid redundancy between
# option(Teem_DEP "<doc>" ON) and set(Teem_DEP OFF CACHE BOOL "<doc>" FORCE)
set(_Teem_dep_doc_ZLIB "Enable nrrd support for zlib (\"gzip\") data encoding")
set(_Teem_dep_doc_PNG "Enable nrrd support for PNG format images")
set(_Teem_dep_doc_BZIP2 "Enable nrrd support for bzip2 data encoding")
set(_Teem_dep_doc_PTHREAD "Enable hoover support for multi-threaded rendering")
set(_Teem_dep_doc_LEVMAR "Build with levmar for better ten and elf")
set(_Teem_dep_doc_FFTW3 "Build with fftw3 to enable nrrdFFT() and `unu fft`")

# Whether to default to DEP being ON or OFF
set(_Teem_dep_dflt_ZLIB ON)
set(_Teem_dep_dflt_PNG ON)
set(_Teem_dep_dflt_BZIP2 OFF)
set(_Teem_dep_dflt_PTHREAD ON)
set(_Teem_dep_dflt_LEVMAR OFF)
set(_Teem_dep_dflt_FFTW3 OFF)

# Add an option() for Teem_USE_DEP for each dependency DEP
foreach(_tdep IN LISTS _Teem_DEPS)
  #     option name                docstring                  default value
  option(Teem_USE_${_tdep}  "${_Teem_dep_doc_${_tdep}}"  ${_Teem_dep_dflt_${_tdep}})
endforeach()

# Other options
option(Teem_BUILD_HEX_UTILS "Build stand-alone raw<-->hex decoder/encoder" OFF)
option(Teem_INSTALL_VERSIONED_PREFIX "Install bin/,lib/,include/ in install/Teem-X.Y.Z subdir" OFF)

###-------------------------------------------------------------------------------------
# RPATH configuration

# Earlier versions of this tried to do clever things so that "make install; make install"
# would not generate errors (on Mac) like:
#  install_name_tool: for: <bin> (for architecture arm64) option
#    "-add_rpath @loader_path/../lib" would duplicate path, file already has LC_RPATH ...
# But it is just too fussy and becomes too complicated.  So instead, see comment later
# below about "clean out old installed RPATH-aware files" in installdir/{bin,lib}:
# we just erase those files first as part of "make install"

if(BUILD_SHARED_LIBS)
  # set(CMAKE_SKIP_RPATH FALSE) # "This is the default unless you explicitly set it TRUE somewhere else. You can drop it"
  if(APPLE)
    # Enable MacOS RPATH support
    set(CMAKE_MACOSX_RPATH ON)
  endif()

  # - - - - - - - - - - - - -
  # Install-tree settings
  #
  # Executables and libraries after 'make install' should be relocatable:
  #   - libraries go in install/lib
  #   - tools in install/bin use @loader_path/../lib (Mac) or $ORIGIN/../lib (Linux)
  set(CMAKE_SKIP_INSTALL_RPATH FALSE)
  set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)  # Avoid adding system paths
  if(APPLE)
    set(CMAKE_INSTALL_RPATH "@loader_path/../lib")
  elseif(UNIX)
    set(CMAKE_INSTALL_RPATH "$ORIGIN/../lib")
  endif()
endif()

###-------------------------------------------------------------------------------------
# Dependency discovery
#  - normalize _Teem_dep_*_DEP pseudo-dictionary variables
#  - run find_package() for requested DEPs

# can't do PNG without ZLIB
if(Teem_USE_PNG AND NOT Teem_USE_ZLIB)
  message(WARNING "PNG requires ZLIB; enabling Teem_USE_ZLIB.")
  set(Teem_USE_ZLIB ON)
endif()

# Special cases of CMake package names (not "DEP")
set(_Teem_dep_cpname_BZIP2   "BZip2")
set(_Teem_dep_cpname_PTHREAD "Threads")
# Special cases of namespace::targetname (not "DEP::DEP")
set(_Teem_dep_target_BZIP2   "BZip2::BZip2")
set(_Teem_dep_target_PTHREAD "Threads::Threads")
set(_Teem_dep_target_FFTW3   "FFTW3::fftw3")
# Special cases of variable name to test for DEP availability (not "DEP_FOUND")
# (yes PTHREAD is special; there isn't  a "Threads_FOUND"; but this enables uniformity)
set(_Teem_dep_found_PTHREAD  "CMAKE_USE_PTHREADS_INIT")
# Special cases of how to name library with -l flag to linker command (not "-ldep")
set(_Teem_dep_llink_ZLIB     "-lz")
set(_Teem_dep_llink_BZIP2    "-lbz2")
set(_Teem_dep_llink_PTHREAD  "-pthread")

# Make sure _Teem_dep_{cpack,target,found,llink}_DEP are defined for all DEPS
# CMake (still) doesn't have anything like a dictionary, so we don't have
# (for example): _Teem_dep_cpname[_tdep]
# but after the following, we do have: ${_Teem_dep_cpname_${_tdep}}
foreach(_tdep IN LISTS _Teem_DEPS)
  if(NOT DEFINED _Teem_dep_cpname_${_tdep})
    set(_Teem_dep_cpname_${_tdep} "${_tdep}")
  endif()
  if(NOT DEFINED _Teem_dep_target_${_tdep})
    set(_Teem_dep_target_${_tdep} "${_tdep}::${_tdep}")
  endif()
  if(NOT DEFINED _Teem_dep_found_${_tdep})
    set(_Teem_dep_found_${_tdep} "${_tdep}_FOUND")
  endif()
  if(NOT DEFINED _Teem_dep_llink_${_tdep})
    string(TOLOWER ${_tdep} _dep_lc)
    set(_Teem_dep_llink_${_tdep} "-l${_dep_lc}")
  endif()
endforeach()

# With all that uniformity set up: try to find_package() for all DEPs requested,
# and set Teem_HAVE_DEP if we did find it (i.e. we "have" it)
foreach(_tdep IN LISTS _Teem_DEPS)
  if(Teem_USE_${_tdep})
    # this DEP is requested
    find_package(${_Teem_dep_cpname_${_tdep}} QUIET)
    if(${_Teem_dep_found_${_tdep}})
      set(Teem_HAVE_${_tdep} TRUE)
    else()
      set(Teem_USE_${_tdep} OFF CACHE BOOL "${_Teem_dep_doc_${_tdep}}" FORCE)
    endif()
  endif()
endforeach()

## to confirm that PNG::PNG links to ZLIB::ZLIB
#get_target_property(_png_libs PNG::PNG INTERFACE_LINK_LIBRARIES)
#message(STATUS "PNG::PNG links to: ${_png_libs}")

###-------------------------------------------------------------------------------------
# Describe install directory layout with variables:
# HEADERS_INSTALL_DIR, LIB_INSTALL_DIR, BIN_INSTALL_DIR, CONFIG_INSTALL_DIR
# which are paths to the different things relative to the install prefix
# (which may be a versioned subdirectory, if requested)
# The CMAKE_INSTALL_* variables were set by include(GNUInstallDirs).

if(Teem_INSTALL_VERSIONED_PREFIX)
  # redefine the whole prefix: <prefix>/Teem-X.Y.Z/
  set(CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}/Teem-${Teem_VERSION_STRING}"
      CACHE PATH "Install path prefix, prepended onto install directories." FORCE)
endif()

# Now just use GNUInstallDirs defaults
set(HEADERS_INSTALL_DIR "${CMAKE_INSTALL_INCLUDEDIR}")
set(LIB_INSTALL_DIR     "${CMAKE_INSTALL_LIBDIR}")
set(BIN_INSTALL_DIR     "${CMAKE_INSTALL_BINDIR}")
set(CONFIG_INSTALL_DIR  "${CMAKE_INSTALL_LIBDIR}/cmake/Teem")

# so that BIN_INSTALL_DIR can be seen by src/bin/CMakeLists.txt
set(BIN_INSTALL_DIR "${BIN_INSTALL_DIR}" CACHE INTERNAL "Install dir for binaries")

###-------------------------------------------------------------------------------------
# Configure-time test: does AIR_EXISTS() work like isfinite()?

# This finishes by setting AIR_EXISTS_MACRO_FAILS
include(CheckAirExists)
# AIR_EXISTS_MACRO_FAILS is used indirectly, below, by configure_file(airExistsConf.h)

###-------------------------------------------------------------------------------------
# Describe the (monolithic) Teem library

add_library(Teem "")

# Ensure build's include dir exists for generated headers
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/include/teem)

# Set Teem target properties about where headers are found
target_include_directories(Teem
  PUBLIC
    $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>
    $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:${HEADERS_INSTALL_DIR}>
)

# For each chosen dependency _tdep, add Teem target properties about:
#  - which -D flags are needed to enable _tdep during compiling,
#  - how to link with _tdep's library at link time
foreach(_tdep IN LISTS _Teem_DEPS)
  if(Teem_HAVE_${_tdep})
    message(STATUS "Will use ${_tdep}: ${_Teem_dep_doc_${_tdep}}")
    # Why PRIVATE for both of these: Teem is designed to not directly expose any thing
    # from, say, png.h or libpng in its API or ABI - there are always stub alternatives
    # for when DEP is not used.  Compiling of Teem-using .c files should not care which
    # dependencies were or were not enabled. Similarly for linking: we use DEP when
    # building the target libteem library, but we should not automatically propagate DEP
    # to executables (like unu) depending on libteem.
    target_compile_definitions(Teem PRIVATE "TEEM_${_tdep}")
    target_link_libraries(Teem PRIVATE "${_Teem_dep_target_${_tdep}}")
  else()
    message(STATUS "  (not using ${_tdep}: ${_Teem_dep_doc_${_tdep}})")
  endif()
endforeach()

# Also: say "cc -D TEEM_STATIC" if not building a shared library
# (used as part of handling Windows "extern" analog)
target_compile_definitions(Teem PUBLIC "$<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:TEEM_STATIC>")

# Do we need to link with -lm? This finishes by setting LIBM_NEEDED
include(CheckLibM)
if(LIBM_NEEDED)
  message(STATUS "Will explicitly link with -lm")
  target_link_libraries(Teem
      PRIVATE  # still link to Teem itself
      INTERFACE m  # this ensures consumers (executables) get -lm automatically
  )
else()
  message(STATUS "Do not need to link with -lm")
endif()

# Set remaining target properties
set_target_properties(Teem PROPERTIES
  OUTPUT_NAME teem  # so we get libteem not libTeem
  VERSION ${Teem_VERSION_STRING}
  SOVERSION ${Teem_VERSION_MAJOR}
  POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS}
)

###-------------------------------------------------------------------------------------
# Collect sources from Teem's component libraries (to make single Teem library)

# Each component library will append its public headers to global property
# "Teem_HEADER_FILES".  For clarity, we initialize it to empty string now.
set_property(GLOBAL PROPERTY Teem_HEADER_FILES "")

# Helper function that a component library calls to declare its contribution
function(_Teem_add_library _pathtolib)
  get_filename_component(_lib ${_pathtolib} NAME)
  cmake_parse_arguments(${_lib} "" "" "SOURCES;PUBLIC_HEADERS" ${ARGN})

  # 1. Prepend containing directory ${_lib} to sources and headers
  set(${_lib}_LIB_SOURCES ${${_lib}_SOURCES})
  list(TRANSFORM ${_lib}_LIB_SOURCES PREPEND "${_lib}/")
  set(${_lib}_LIB_PUBLIC_HEADERS ${${_lib}_PUBLIC_HEADERS})
  list(TRANSFORM ${_lib}_LIB_PUBLIC_HEADERS PREPEND "${_lib}/")

  # 2. Collect public headers for installation
  set_property(GLOBAL APPEND PROPERTY Teem_HEADER_FILES ${${_lib}_LIB_PUBLIC_HEADERS})

  # 3. Add all .c sources for compilation
  # (.h headers will be seen via dependency analysis)
  target_sources(Teem PRIVATE ${${_lib}_SOURCES})

  # 4. IDE grouping of library using TREE under single "Teem/src" prefix
  source_group(
    TREE "${CMAKE_CURRENT_SOURCE_DIR}/${_lib}"
    PREFIX "Teem/src/${_lib}"
    FILES
      ${${_lib}_LIB_SOURCES}
      ${${_lib}_LIB_PUBLIC_HEADERS}
  )
endfunction()

# Read in CMakeLists.txt of each library; each one is just a _Teem_add_library() call
# (TEEM_LIB_LIST)
set(Teem_LIBRARIES
    air hest biff nrrd ell moss unrrdu alan tijk gage dye bane
    limn echo hoover seek ten elf pull coil push mite meet)
foreach(_dir IN LISTS Teem_LIBRARIES)
  add_subdirectory(src/${_dir})
endforeach()

if(0)  # inspecting the properties set so far
  # confirm results of prior target_link_libraries(PRIVATE)s
  # (what dependencies do I consume)
  get_target_property(_Teem_libs Teem LINK_LIBRARIES)
  message(STATUS "Teem LINK_LIBRARIES = ${_Teem_libs}")

  ## Not interesting for Teem: what dependencies do I expose
  #get_target_property(_Teem_libs Teem INTERFACE_LINK_LIBRARIES)
  #message(STATUS "Teem INTERFACE_LINK_LIBRARIES = ${_Teem_libs}")
  ## This will show "_Teem_libs-NOTFOUND" because of
  ## Teem's API/ABI invariance w.r.t dependencies

  # confirm results of prior target_include_directories()s:
  # PRIVATE   --> INCLUDE_DIRECTORIES
  # PUBLIC    --> INCLUDE_DIRECTORIES and INTERFACE_INCLUDE_DIRECTORIES
  # INTERFACE --> INTERFACE_INCLUDE_DIRECTORIES
  get_target_property(_teem_incdirs Teem INCLUDE_DIRECTORIES)
  message(STATUS "Teem INCLUDE_DIRECTORIES: ${_teem_incdirs}")
  get_target_property(_teem_inter_incdirs Teem INTERFACE_INCLUDE_DIRECTORIES)
  message(STATUS "Teem INTERFACE_INCLUDE_DIRECTORIES: ${teem_inter_incdirs}")

  # confirm results of prior target_compile_definitions()s:
  # PRIVATE   --> COMPILE_DEFINITIONS
  # PUBLIC    --> COMPILE_DEFINITIONS and INTERFACE_COMPILE_DEFINITIONS
  # INTERFACE --> INTERFACE_COMPILE_DEFINITIONS
  get_target_property(_teem_compdefs Teem COMPILE_DEFINITIONS)
  message(STATUS "Teem COMPILE_DEFINITIONS: ${_teem_compdefs}")
  get_target_property(_teem_inter_compdefs Teem INTERFACE_INCLUDE_DIRECTORIES)
  message(STATUS "Teem INTERFACE_COMPILE_DEFINITIONS: ${teem_inter_compdefs}")
endif()

###-------------------------------------------------------------------------------------
# Declare Teem's public headers

# Set *variable* _Teem_headers from previously set *property* Teem_HEADER_FILES
get_property(_Teem_headers GLOBAL PROPERTY Teem_HEADER_FILES)
# cmake_print_variables(_Teem_headers)

# Copy header files from source into build
set(_Teem_headers_full)
foreach(_dirhdr IN LISTS _Teem_headers)
  # e.g. set _hdr="air.h" from _dirhdr="air/air.h"
  get_filename_component(_hdr ${_dirhdr} NAME)
  set(_dest "${CMAKE_BINARY_DIR}/include/teem/${_hdr}")
  # cmake_print_variables(_dirhdr _dest)
  configure_file(${CMAKE_CURRENT_SOURCE_DIR}/src/${_dirhdr} ${_dest} COPYONLY)
  list(APPEND _Teem_headers_full "${_dest}")
endforeach()
# cmake_print_variables(_Teem_headers_full)

# Configure generated header airExistsConf.h
# *This* is where AIR_EXISTS_MACRO_FAILS (set above) is actually used;
# teem/CMake/airExistsConf.h contains the line:
#   #cmakedefine AIR_EXISTS_MACRO_FAILS
# which is transformed to
#   #define AIR_EXISTS_MACRO_FAILS
# so that teem/src/air/air.h's definition of AIR_EXISTS can fall back on airExists()
configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CMake/airExistsConf.h
               ${CMAKE_BINARY_DIR}/include/teem/airExistsConf.h
               @ONLY NEWLINE_STYLE UNIX)
list(APPEND _Teem_headers_full "${CMAKE_BINARY_DIR}/include/teem/airExistsConf.h")

# Declare the set of public header files that belong to the Teem library.
# - "FILE_SET public_headers" groups them under a set named "public_headers",
#   so that install(TARGETS) can reference it
# - "BASE_DIRS ${CMAKE_BINARY_DIR}/include" names the directory that the
#   headers are considered relative to, so that when Teem is installed,
#   the include tree layout is preserved so users can #include <teem/air.h>
target_sources(Teem
  PUBLIC
    FILE_SET public_headers
    TYPE HEADERS  # these are headers, no sources
    BASE_DIRS ${CMAKE_BINARY_DIR}/include
    FILES ${_Teem_headers_full} # the list of header files
)

###-------------------------------------------------------------------------------------
# Describe Teem's command-line executables (e.g. "unu")

# Only on Mac with shared libraries: clean out old installed RPATH-aware files before
# installing new ones, because getting the RPATH stuff to be set correctly after the
# first "make install", but *not* modified after a second "make install", is just too
# annoying to figure out.  This hack has to *precede* any other install() commands, which
# is why this shows up here, before src/bin/CMakeLists.txt's teem_add_executable() can
# call install()
if(BUILD_SHARED_LIBS)
  if(APPLE)
    install(CODE "
      file(GLOB old_bins \"\$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/bin/*\")
      file(GLOB old_libs \"\$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/lib/*\")
      if(old_bins OR old_libs)
        message(STATUS \"Removing prior \$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/{bin,lib}/* rather than attempt RPATH surgery\")
      endif()
      if(old_bins)
        file(REMOVE \${old_bins})
      endif()
      if(old_libs)
        file(REMOVE \${old_libs})
      endif()
    ")
  endif()
endif()

# Describe all the command-line tools (unu and friends)
add_subdirectory(src/bin)

###-------------------------------------------------------------------------------------
# Optional helper tools (hex/dehex)

# If requested, helper dehex/exhex programs
if(Teem_BUILD_HEX_UTILS)
  add_subdirectory(src/hex)
endif()

###-------------------------------------------------------------------------------------
# Testing via CTest
# Note: these tests are very incomplete. It is unclear how much of Teem's future
# development will hinge on CTest-based testing, now that the Python/CFFI bindings
# offer a much more convenient way to call into Teem.

if(BUILD_TESTING)
  add_subdirectory(tests/ctest)
endif()

###-------------------------------------------------------------------------------------
# Install rules to create the CMake package

# Declare how Teem should be installed, and hang all this off the "TeemTargets" export
# set. This does not copy files immediately; it only registers installation rules, which
# are applied at `cmake --install` time
install(TARGETS Teem
  EXPORT TeemTargets
  LIBRARY DESTINATION ${LIB_INSTALL_DIR}
  ARCHIVE DESTINATION ${LIB_INSTALL_DIR}
  RUNTIME DESTINATION ${BIN_INSTALL_DIR}
  FILE_SET public_headers DESTINATION ${HEADERS_INSTALL_DIR}
)

include(CMakePackageConfigHelpers)

# Generate TeemConfig.cmake from template CMake/TeemConfig.cmake.in.
# We have to do some work to teach Teem to pull in its own dependencies.
# First, build up list of find_dependency() calls for TeemConfig.cmake:
set(_Teem_find_deps "")
foreach(_tdep IN LISTS _Teem_DEPS)
  if(Teem_USE_${_tdep})
    if(NOT _Teem_find_deps)
      # before first dependency, we have to say how to find_dependency()
      string(APPEND _Teem_find_deps "include(CMakeFindDependencyMacro)\n")
    endif()
    # Map to CMake package name
    string(APPEND _Teem_find_deps "find_dependency(${_Teem_dep_cpname_${_tdep}} REQUIRED)\n")
  endif()
endforeach()
if(NOT _Teem_find_deps)
  # if, actually, there aren't any dependencies, add a comment saying so
  string(APPEND _Teem_find_deps "# (actually, no dependencies in this Teem build)\n")
endif()
# Then, empower the upcoming configure_package_config_file command to convert
# @Teem_CONFIG_DEPENDENCIES@ (appearing in TeemConfig.cmake.in) to ${_Teem_find_deps}
set(Teem_CONFIG_DEPENDENCIES "${_Teem_find_deps}")
# If we redefined CMAKE_INSTALL_PREFIX (because Teem_INSTALL_VERSIONED_PREFIX was ON),
# record it for TeemConfig.cmake
set(Teem_EFFECTIVE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")
# now finally generate TeemConfig.cmake
configure_package_config_file(
  ${CMAKE_CURRENT_SOURCE_DIR}/CMake/TeemConfig.cmake.in
  ${CMAKE_CURRENT_BINARY_DIR}/TeemConfig.cmake
  INSTALL_DESTINATION ${CONFIG_INSTALL_DIR}
)

# Generate version file (so find_package can check Teem >= X.Y.Z)
write_basic_package_version_file(
  ${CMAKE_CURRENT_BINARY_DIR}/TeemConfigVersion.cmake
  VERSION ${Teem_VERSION_STRING}
  # Teem v2 does have non-zero ABI and API changes from Teem pre-v2, hence the
  # SameMajorVersion instead of AnyNewerVersion below.  Most Teem-using code will likely
  # not need changing to use v2, but it does need to be recompiled.  To honor the
  # expectations of the semantic versioning that Teem adopted in 2005 with version
  # 1.9.0, the major version boundary has to mean something
  COMPATIBILITY SameMajorVersion
)

# Export targets (defined earlier via add_library + install(TARGETS â€¦))
install(EXPORT TeemTargets
  FILE TeemTargets.cmake
  NAMESPACE Teem::
  DESTINATION ${CONFIG_INSTALL_DIR}
)

# Install the package config and version files
install(FILES
  ${CMAKE_CURRENT_BINARY_DIR}/TeemConfig.cmake
  ${CMAKE_CURRENT_BINARY_DIR}/TeemConfigVersion.cmake
  DESTINATION ${CONFIG_INSTALL_DIR}
)

# Install copy of the LICENSE.txt as LICENSE
install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.txt
        DESTINATION ${CMAKE_INSTALL_DATADIR}/Teem
        RENAME LICENSE)

###-------------------------------------------------------------------------------------
# For non-CMake consumers: create teem.pc for pkg-config, and teem-config script

# Collect all private -llib dependency flags
set(_pc_private_libs "")
foreach(_tdep IN LISTS _Teem_DEPS)
  if(Teem_HAVE_${_tdep})
    string(APPEND _pc_private_libs " ${_Teem_dep_llink_${_tdep}}")
  endif()
endforeach()
if(LIBM_NEEDED)
  string(APPEND _pc_private_libs " -lm")
endif()
set(Teem_PC_PRIVATE_LIBS "${_pc_private_libs}")

# Generate pkg-config teem.pc file
configure_file(
  ${CMAKE_CURRENT_SOURCE_DIR}/CMake/teem.pc.in
  ${CMAKE_CURRENT_BINARY_DIR}/teem.pc @ONLY
)
install(FILES ${CMAKE_CURRENT_BINARY_DIR}/teem.pc
  DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig
)

# Generate teem-config helper script
configure_file(
  ${CMAKE_CURRENT_SOURCE_DIR}/CMake/teem-config.in
  ${CMAKE_CURRENT_BINARY_DIR}/teem-config @ONLY
)
install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/teem-config
  DESTINATION ${CMAKE_INSTALL_BINDIR}
)
