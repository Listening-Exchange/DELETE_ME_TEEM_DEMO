#
# Teem: Tools to process and visualize scientific data and images
# Copyright (C) 2009--2025  University of Chicago
# Copyright (C) 2005--2008  Gordon Kindlmann
# Copyright (C) 1998--2004  University of Utah
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# (LGPL) as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# The terms of redistributing and/or modifying this software also
# include exceptions to the LGPL that facilitate static linking.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, see <https://www.gnu.org/licenses/>.
#

# Teem/CMakeLists.txt Version 10.94

# This CMakeLists.txt describes a Teem package that contains:
# (1) a library ("libteem" on unix) and
# (2) associated command-line tools (like "unu").

# Teem is itself made of component libraries (air, hest, biff, nrrd, etc.) but in CMake
# we do not compile these as libraries per se: they are merely containers for .c and .h
# files, which we compile to a single "monolithic" library. Teem also has a separate
# system of GNUmakefiles (re-written for Teem v2) which do build the finer-grained
# per-component libraries (libair.a, libhest.a, etc). These remain useful for Teem
# development, but there's no reason to complicate this CMakeLists.txt with describing
# those smaller libraries and their inter-dependencies.

###-------------------------------------------------------------------------------------
# Project setup: version, metadata, and language

# CMake Version 3.25 came out November 16, 2022
# https://www.kitware.com/cmake-3-25-0-available-for-download/
# why use 3.25: has nicer syntax for try_compile
cmake_minimum_required(VERSION 3.25)

# Teem version number (must match values in src/air/air.h)
set(Teem_VERSION_MAJOR 1)
set(Teem_VERSION_MINOR 12)
set(Teem_VERSION_PATCH 0)
set(Teem_VERSION_STRING ${Teem_VERSION_MAJOR}.${Teem_VERSION_MINOR}.${Teem_VERSION_PATCH})

project(Teem VERSION ${Teem_VERSION_STRING}
        DESCRIPTION "Teem libraries developed by Gordon Kindlmann et al."
        HOMEPAGE_URL "https://teem.sourceforge.net/"
        LANGUAGES C)

message(STATUS "


********************************************************************
** Please join the Teem-users discord https://discord.gg/xBBqZGXkF7
** to share how Teem works or does not work for you!
** For example, are these re-written CMakeLists.txt files working?
********************************************************************


")

###-------------------------------------------------------------------------------------
# Include helpers and module paths

# include(CTest) will create the BUILD_TESTING option, turn it ON, hook into CTest, and
# in turn include(CTestConfig.cmake). Most of which is fine, but we want to turn
# BUILD_TESTING OFF by default and give a better description
set(BUILD_TESTING OFF CACHE BOOL "Build Teem's *meagre* ctests")
include(CTest)

# https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html
include(GNUInstallDirs)      # sets CMAKE_INSTALL_*DIR variables
include(CMakeParseArguments) # for cmake_parse_arguments
include(CMakePrintHelpers)   # for debugging via cmake_print_variables(varname)

# CMake modules path (for e.g. FindLEVMAR.cmake)
set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/CMake")

###-------------------------------------------------------------------------------------
# Project options, including choosing dependencies
#  - canonical list of optional dependencies
#  - option() flags for enabling/disabling them

# Do we make a shared library?  BUILD_SHARED_LIBS has particular meaning to CMake
#   https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
#   https://gitlab.kitware.com/cmake/cmake/-/issues/25699
option(BUILD_SHARED_LIBS "Build a libteem shared library" ON)

# The canonical list of libraries that Teem can (optionally) depend on. Within this
# CMakeLists.txt file, each one is a "DEP" or dependency However, FYI, within the
# GNUmakefiles, each is called an EXT or external.  Note: inter-dependency dependencies
# are known in the INTERFACE_LINK_LIBRARIES of each target.
set(_Teem_DEPS PNG ZLIB BZIP2 LEVMAR FFTW3 PTHREAD)

# docstrings of all dependencies, to avoid redundancy between
# option(Teem_DEP "${_doc}" ON) and set(Teem_DEP OFF CACHE BOOL "${_doc}" FORCE)
set(_doc_ZLIB "Enable nrrd support for zlib (\"gzip\") data encoding")
set(_doc_PNG "Enable nrrd support for PNG format images")
set(_doc_BZIP2 "Enable nrrd support for bzip2 data encoding")
set(_doc_PTHREAD "Enable hoover support for multi-threaded rendering")
set(_doc_LEVMAR "Build with levmar for better elf and ten")
set(_doc_FFTW3 "Build with fftw3 to enable nrrdFFT() and `unu fft`")

# Whether to default to DEP being ON or OFF
set(_dflt_ZLIB ON)
set(_dflt_PNG ON)
set(_dflt_BZIP2 OFF)
set(_dflt_PTHREAD ON)
set(_dflt_LEVMAR OFF)
set(_dflt_FFTW3 OFF)

# Add an option() for Teem_USE_DEP for each dependency DEP
foreach(_tdep IN LISTS _Teem_DEPS)
  #     option name         docstring           default value
  option(Teem_USE_${_tdep}  "${_doc_${_tdep}}"  ${_dflt_${_tdep}})
endforeach()

# Other options
option(Teem_BUILD_HEX_UTILS "Build stand-alone raw<-->hex decoder/encoder" OFF)
option(Teem_INSTALL_VERSIONED_PREFIX "Install bin/,lib/,include/ in install/Teem-X.Y.Z subdir" OFF)

###-------------------------------------------------------------------------------------
# RPATH configuration

# Earlier versions of this tried to do clever things so that "make install; make install"
# would not generate errors (on Mac) like:
#  install_name_tool: for: <bin> (for architecture arm64) option
#    "-add_rpath @loader_path/../lib" would duplicate path, file already has LC_RPATH ...
# But it is just too fussy and becomes too complicated.  So instead, see comment later
# below about "clean out old installed RPATH-aware files" in installdir/{bin,lib}:
# we just erase those files first as part of "make install"

if(BUILD_SHARED_LIBS)
  # set(CMAKE_SKIP_RPATH FALSE) # "This is the default unless you explicitly set it TRUE somewhere else. You can drop it"
  if(APPLE)
    # Enable MacOS RPATH support
    set(CMAKE_MACOSX_RPATH ON)
  endif()

  # - - - - - - - - - - - - -
  # Install-tree settings
  #
  # Executables and libraries after 'make install' should be relocatable:
  #   - libraries go in install/lib
  #   - tools in install/bin use @loader_path/../lib (Mac) or $ORIGIN/../lib (Linux)
  set(CMAKE_SKIP_INSTALL_RPATH FALSE)
  set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)  # Avoid adding system paths
  if(APPLE)
    set(CMAKE_INSTALL_RPATH "@loader_path/../lib")
  elseif(UNIX)
    set(CMAKE_INSTALL_RPATH "$ORIGIN/../lib")
  endif()
endif()

###-------------------------------------------------------------------------------------
# Dependency discovery
#  - normalize names/targets/FOUND vars
#  - run find_package() for requested DEPs

# can't do PNG without ZLIB
if(Teem_USE_PNG AND NOT Teem_USE_ZLIB)
  message(WARNING "PNG requires ZLIB; enabling Teem_USE_ZLIB.")
  set(Teem_USE_ZLIB ON)
endif()

# Special cases of CMake package names (not "DEP")
set(_cpname_BZIP2    "BZip2")
set(_cpname_PTHREAD  "Threads")
# Special cases of namespace::targetname (not "DEP::DEP")
set(_target_BZIP2   "BZip2::BZip2")
set(_target_PTHREAD "Threads::Threads")
set(_target_FFTW3   "FFTW3::fftw3")
# Special cases of variable name to test for DEP availability (not "DEP_FOUND")
# (yes PTHREAD is special; there isn't  a "Threads_FOUND"; but this enables uniformity)
set(_found_PTHREAD  "CMAKE_USE_PTHREADS_INIT")

# Make sure _{cpack,target,found}_DEP are defined for all DEPS
foreach(_tdep IN LISTS _Teem_DEPS)
  if(NOT DEFINED _cpname_${_tdep})
    set(_cpname_${_tdep} "${_tdep}")
  endif()
  if(NOT DEFINED _target_${_tdep})
    set(_target_${_tdep} "${_tdep}::${_tdep}")
  endif()
  if(NOT DEFINED _found_${_tdep})
    set(_found_${_tdep} "${_tdep}_FOUND")
  endif()
endforeach()
# CMake (still) doesn't have anything like a dictionary,
# so we don't have (for example): _cpname[_tdep]
# but now, after the foreach above, we have: ${_cpname_${_tdep}}

# With all that uniformity set up: try to find_package() for all DEPs requested,
# and set Teem_HAVE_DEP if we did find it (i.e. we "have" it)
foreach(_tdep IN LISTS _Teem_DEPS)
  if(Teem_USE_${_tdep})
    # this DEP is requested
    find_package(${_cpname_${_tdep}} QUIET)
    if(${_found_${_tdep}})
      set(Teem_HAVE_${_tdep} TRUE)
    else()
      set(Teem_USE_${_tdep} OFF CACHE BOOL "${_doc_${_tdep}}" FORCE)
    endif()
  endif()
endforeach()

## to confirm that PNG::PNG links to ZLIB::ZLIB
#get_target_property(_png_libs PNG::PNG INTERFACE_LINK_LIBRARIES)
#message(STATUS "PNG::PNG links to: ${_png_libs}")

###-------------------------------------------------------------------------------------
# Describe install directory layout with variables:
# HEADERS_INSTALL_DIR, LIB_INSTALL_DIR, BIN_INSTALL_DIR, CONFIG_INSTALL_DIR
# which are paths to the different things relative to the install prefix
# (which may be a versioned subdirectory, if requested)
# The CMAKE_INSTALL_* variables were set by include(GNUInstallDirs).

if(Teem_INSTALL_VERSIONED_PREFIX)
  # redefine the whole prefix: <prefix>/Teem-X.Y.Z/
  set(CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}/Teem-${Teem_VERSION_STRING}"
      CACHE PATH "Install path prefix, prepended onto install directories." FORCE)
endif()

# Now just use GNUInstallDirs defaults
set(HEADERS_INSTALL_DIR "${CMAKE_INSTALL_INCLUDEDIR}")
set(LIB_INSTALL_DIR     "${CMAKE_INSTALL_LIBDIR}")
set(BIN_INSTALL_DIR     "${CMAKE_INSTALL_BINDIR}")
set(CONFIG_INSTALL_DIR  "${CMAKE_INSTALL_LIBDIR}/cmake/Teem")

# so that BIN_INSTALL_DIR can be seen by src/bin/CMakeLists.txt
set(BIN_INSTALL_DIR "${BIN_INSTALL_DIR}" CACHE INTERNAL "Install dir for binaries")

###-------------------------------------------------------------------------------------
# Configure-time test: does AIR_EXISTS() work like isfinite()?

# A lot of work for one little macro (which GLK started using before the functionally
# equivalent isfinite() became widely available).  The little CMake/TestAIR_EXISTS.c
# program tests the equivalent of AIR_EXISTS (but without directly using air.h's
# AIR_EXISTS because this has to be stand-alone), to see if it can correctly detect
# IEEE754 special values (NaNs and infinities). For this to be a useful test that informs
# how the rest of Teem code will work, TestAIR_EXISTS.c needs to be compiled the same as
# Teem itself will be compiled later.  Sadly, it was not until Teem V2 that this
# consistency was actually enforced (!)  To further help debugging, we also print out
# exactly how TestAIR_EXISTS.c is compiled, and we use try_compile instead of try_run
# so the resulting executable file stays available for later inspection.
#
# (rejected but interesting debugging strategies:
#  message(STATUS "Pausing CMake so you can inspect temporary files...")
#  execute_process(COMMAND ${CMAKE_COMMAND} -E sleep 30)
#  or
#  execute_process(COMMAND /bin/sh -c "read -p 'Press ENTER to continue...'")
# )

# "taex" = Test Air_EXists
set(_taex_src "${CMAKE_CURRENT_LIST_DIR}/CMake/TestAIR_EXISTS.c")

# Build flags for the probe (same as Teem itself)
string(TOUPPER "${CMAKE_BUILD_TYPE}" _taex_BTUC)
set(_taex_flags "${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${_taex_BTUC}}")
set(_taex_me "AIR_EXISTS (compiled \"${_taex_flags}\")")

# Where we want a durable copy of the compiled probe
if(WIN32)
  set(_taex_copy "${CMAKE_BINARY_DIR}/TestAIR_EXISTS.exe")
else()
  set(_taex_copy "${CMAKE_BINARY_DIR}/TestAIR_EXISTS")
endif()

# Remove any stale copy from previous runs
if(EXISTS "${_taex_copy}")
  file(REMOVE "${_taex_copy}")
endif()

# Compile the probe
message(CHECK_START "Testing whether macro ${_taex_me} detects IEEE754 special values")
try_compile(
  _taex_compiles         # boolean result: TRUE if compile succeeded
  SOURCES "${_taex_src}" # one or more source files for the test
  CMAKE_FLAGS
    "-DCMAKE_VERBOSE_MAKEFILE=ON"
    "-DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}"
    "-DCMAKE_C_FLAGS_${_taex_BTUC}=${_taex_flags}"
    "-DCMAKE_DEPENDS_USE_COMPILER=FALSE"  # no -MD/-MT/-MF dependency cruft
  COPY_FILE "${_taex_copy}"     # copy the built executable to a stable path
  OUTPUT_VARIABLE _taex_compile_out
  COPY_FILE_ERROR _taex_copy_error
)
# Always show the captured compile output, as progress indication
string(REPLACE "\n" "\n     " _taex_compile_out_indented "${_taex_compile_out}")
message(STATUS "Compile output:\n     ${_taex_compile_out_indented}")

if(NOT _taex_compiles)
  message(CHECK_FAIL "compile failed")
  message(FATAL_ERROR "Could not compile ${_taex_src}")
elseif(_taex_copy_error)
  message(CHECK_FAIL "copy failed")
  message(FATAL_ERROR "Test program compiled but could not copy: ${_taex_copy_error}")
elseif(NOT EXISTS "${_taex_copy}")
  message(CHECK_FAIL "missing executable")
  message(FATAL_ERROR "Test program compiled but file not found at ${_taex_copy}")
else()
  message(CHECK_PASS "compiled successfully")
endif()

# Run the test program
message(CHECK_START "Running ${_taex_me} test program")
# https://cmake.org/cmake/help/latest/command/execute_process.html
execute_process(
  COMMAND "${_taex_copy}"
  RESULT_VARIABLE _taex_run_status
  OUTPUT_VARIABLE _taex_run_out
  ERROR_VARIABLE _taex_run_err
)

# Act on the results; set AIR_EXISTS_MACRO_FAILS
if(_taex_run_status EQUAL 0)
  message(CHECK_PASS "Yes, it detects IEEE754 special values")
  set(AIR_EXISTS_MACRO_FAILS 0 CACHE INTERNAL "AIR_EXISTS macro works correctly")
else()
    # Always show stdout/stderr from the probe as indented sub-log
  if(_taex_run_out)
    string(REPLACE "\n" "\n     " _taex_run_out_indented "${_taex_run_out}")
    message(STATUS "Probe stdout:\n     ${_taex_run_out_indented}")
  endif()
  if(_taex_run_err)
    string(REPLACE "\n" "\n     " _taex_run_err_indented "${_taex_run_err}")
    message(STATUS "Probe stderr:\n     ${_taex_run_err_indented}")
  endif()
  message(CHECK_FAIL "NO, it FAILS to detect IEEE754 special values")
  set(AIR_EXISTS_MACRO_FAILS 1 CACHE INTERNAL "AIR_EXISTS macro fails")
endif()
# AIR_EXISTS_MACRO_FAILS is used indirectly, below, by configure_file(airExistsConf.h)

###-------------------------------------------------------------------------------------
# Describe the (monolithic) Teem library

add_library(Teem "")

# Ensure build's include dir exists for generated headers
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/include/teem)

# Set Teem target properties about where headers are found
target_include_directories(Teem
  PUBLIC
    $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>
    $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:${HEADERS_INSTALL_DIR}>
)

# For each chosen dependency _tdep, add Teem target properties about:
#  - which -D flags are needed to enable _tdep during compiling,
#  - how to link with _tdep's library at link time
foreach(_tdep IN LISTS _Teem_DEPS)
  if(Teem_HAVE_${_tdep})
    message(STATUS "Will use ${_tdep}: ${_doc_${_tdep}}")
    # Why PRIVATE for both of these: Teem is designed to not directly expose any thing
    # from, say, png.h or libpng in its API or ABI - there are always stub alternatives
    # for when DEP is not used.  Compiling of Teem-using .c files should not care which
    # dependencies were or were not enabled. Similarly for linking: we use DEP when
    # building the target libteem library, but we should not automatically propagate DEP
    # to executables (like unu) depending on libteem.
    target_compile_definitions(Teem PRIVATE "TEEM_${_tdep}")
    target_link_libraries(Teem PRIVATE "${_target_${_tdep}}")
  else()
    message(STATUS "  (not using ${_tdep}: ${_doc_${_tdep}})")
  endif()
endforeach()

# Also: say "cc -D TEEM_STATIC" if not building a shared library
# (used as part of handling Windows "extern" analog)
target_compile_definitions(Teem PUBLIC "$<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:TEEM_STATIC>")

# brute-force: add -lm to link line for any and all Unices:
if(UNIX)
  target_link_libraries(Teem PRIVATE m)
endif()

# Set remaining target properties
set_target_properties(Teem PROPERTIES
  OUTPUT_NAME teem  # so we get libteem not libTeem
  VERSION ${Teem_VERSION_STRING}
  SOVERSION ${Teem_VERSION_MAJOR}
  POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS}
)

###-------------------------------------------------------------------------------------
# Collect sources from Teem's component libraries (to make single Teem library)

# Each component library will append its public headers to global property
# "Teem_HEADER_FILES".  For clarity, we initialize it to empty string now.
set_property(GLOBAL PROPERTY Teem_HEADER_FILES "")

# Helper function that a component library calls to declare its contribution
function(_Teem_add_library _pathtolib)
  get_filename_component(_lib ${_pathtolib} NAME)
  cmake_parse_arguments(${_lib} "" "" "SOURCES;PUBLIC_HEADERS" ${ARGN})

  # 1. Prepend containing directory ${_lib} to sources and headers
  set(${_lib}_LIB_SOURCES ${${_lib}_SOURCES})
  list(TRANSFORM ${_lib}_LIB_SOURCES PREPEND "${_lib}/")
  set(${_lib}_LIB_PUBLIC_HEADERS ${${_lib}_PUBLIC_HEADERS})
  list(TRANSFORM ${_lib}_LIB_PUBLIC_HEADERS PREPEND "${_lib}/")

  # 2. Collect public headers for installation
  set_property(GLOBAL APPEND PROPERTY Teem_HEADER_FILES ${${_lib}_LIB_PUBLIC_HEADERS})

  # 3. Add all .c sources for compilation
  # (.h headers will be seen via dependency analysis)
  target_sources(Teem PRIVATE ${${_lib}_SOURCES})

  # 4. IDE grouping of library using TREE under single "Teem/src" prefix
  source_group(
    TREE "${CMAKE_CURRENT_SOURCE_DIR}/${_lib}"
    PREFIX "Teem/src/${_lib}"
    FILES
      ${${_lib}_LIB_SOURCES}
      ${${_lib}_LIB_PUBLIC_HEADERS}
  )
endfunction()

# Read in CMakeLists.txt of each library; each one is just a _Teem_add_library() call
# (TEEM_LIB_LIST)
set(Teem_LIBRARIES
    air hest biff nrrd ell moss unrrdu alan tijk gage dye bane
    limn echo hoover seek ten elf pull coil push mite meet)
foreach(_dir IN LISTS Teem_LIBRARIES)
  add_subdirectory(src/${_dir})
endforeach()

if(0)  # inspecting the properties set so far
  # confirm results of prior target_link_libraries(PRIVATE)s
  # (what dependencies do I consume)
  get_target_property(_Teem_libs Teem LINK_LIBRARIES)
  message(STATUS "Teem LINK_LIBRARIES = ${_Teem_libs}")

  ## Not interesting for Teem: what dependencies do I expose
  #get_target_property(_Teem_libs Teem INTERFACE_LINK_LIBRARIES)
  #message(STATUS "Teem INTERFACE_LINK_LIBRARIES = ${_Teem_libs}")
  ## This will show "_Teem_libs-NOTFOUND" because of
  ## Teem's API/ABI invariance w.r.t dependencies

  # confirm results of prior target_include_directories()s:
  # PRIVATE   --> INCLUDE_DIRECTORIES
  # PUBLIC    --> INCLUDE_DIRECTORIES and INTERFACE_INCLUDE_DIRECTORIES
  # INTERFACE --> INTERFACE_INCLUDE_DIRECTORIES
  get_target_property(_teem_incdirs Teem INCLUDE_DIRECTORIES)
  message(STATUS "Teem INCLUDE_DIRECTORIES: ${_teem_incdirs}")
  get_target_property(_teem_inter_incdirs Teem INTERFACE_INCLUDE_DIRECTORIES)
  message(STATUS "Teem INTERFACE_INCLUDE_DIRECTORIES: ${teem_inter_incdirs}")

  # confirm results of prior target_compile_definitions()s:
  # PRIVATE   --> COMPILE_DEFINITIONS
  # PUBLIC    --> COMPILE_DEFINITIONS and INTERFACE_COMPILE_DEFINITIONS
  # INTERFACE --> INTERFACE_COMPILE_DEFINITIONS
  get_target_property(_teem_compdefs Teem COMPILE_DEFINITIONS)
  message(STATUS "Teem COMPILE_DEFINITIONS: ${_teem_compdefs}")
  get_target_property(_teem_inter_compdefs Teem INTERFACE_INCLUDE_DIRECTORIES)
  message(STATUS "Teem INTERFACE_COMPILE_DEFINITIONS: ${teem_inter_compdefs}")
endif()

###-------------------------------------------------------------------------------------
# Declare Teem's public headers

# Set *variable* _Teem_headers from previously set *property* Teem_HEADER_FILES
get_property(_Teem_headers GLOBAL PROPERTY Teem_HEADER_FILES)
# cmake_print_variables(_Teem_headers)

# Copy header files from source into build
set(_Teem_headers_full)
foreach(_dirhdr IN LISTS _Teem_headers)
  # e.g. set _hdr="air.h" from _dirhdr="air/air.h"
  get_filename_component(_hdr ${_dirhdr} NAME)
  set(_dest "${CMAKE_BINARY_DIR}/include/teem/${_hdr}")
  # cmake_print_variables(_dirhdr _dest)
  configure_file(${CMAKE_CURRENT_SOURCE_DIR}/src/${_dirhdr} ${_dest} COPYONLY)
  list(APPEND _Teem_headers_full "${_dest}")
endforeach()
# cmake_print_variables(_Teem_headers_full)

# Configure generated header airExistsConf.h
# *This* is where AIR_EXISTS_MACRO_FAILS (set above) is actually used;
# teem/CMake/airExistsConf.h contains the line:
#   #cmakedefine AIR_EXISTS_MACRO_FAILS
# which is transformed to
#   #define AIR_EXISTS_MACRO_FAILS
# so that teem/src/air/air.h's definition of AIR_EXISTS can fall back on airExists()
configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CMake/airExistsConf.h
               ${CMAKE_BINARY_DIR}/include/teem/airExistsConf.h
               @ONLY NEWLINE_STYLE UNIX)
list(APPEND _Teem_headers_full "${CMAKE_BINARY_DIR}/include/teem/airExistsConf.h")

# Declare the set of public header files that belong to the Teem library.
# - "FILE_SET public_headers" groups them under a set named "public_headers",
#   so that install(TARGETS) can reference it
# - "BASE_DIRS ${CMAKE_BINARY_DIR}/include" names the directory that the
#   headers are considered relative to, so that when Teem is installed,
#   the include tree layout is preserved so users can #include <teem/air.h>
target_sources(Teem
  PUBLIC
    FILE_SET public_headers
    TYPE HEADERS  # these are headers, no sources
    BASE_DIRS ${CMAKE_BINARY_DIR}/include
    FILES ${_Teem_headers_full} # the list of header files
)

###-------------------------------------------------------------------------------------
# Describe Teem's command-line executables (e.g. "unu")

# Only on Mac with shared libraries: clean out old installed RPATH-aware files before
# installing new ones, because getting the RPATH stuff to be set correctly after the
# first "make install", but *not* modified after a second "make install", is just too
# annoying to figure out.  This hack has to *precede* any other install() commands, which
# is why this shows up here, before src/bin/CMakeLists.txt's teem_add_executable() can
# call install()
if(BUILD_SHARED_LIBS)
  if(APPLE)
    install(CODE "
      file(GLOB old_bins \"\$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/bin/*\")
      file(GLOB old_libs \"\$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/lib/*\")
      if(old_bins OR old_libs)
        message(STATUS \"Removing prior \$ENV{DESTDIR}${CMAKE_INSTALL_PREFIX}/{bin,lib}/* rather than attempt RPATH surgery\")
      endif()
      if(old_bins)
        file(REMOVE \${old_bins})
      endif()
      if(old_libs)
        file(REMOVE \${old_libs})
      endif()
    ")
  endif()
endif()

# Describe all the command-line tools (unu and friends)
add_subdirectory(src/bin)

###-------------------------------------------------------------------------------------
# Optional helper tools (hex/dehex)

# If requested, helper dehex/exhex programs
if(Teem_BUILD_HEX_UTILS)
    add_subdirectory(src/hex)
endif()

###-------------------------------------------------------------------------------------
# Testing via CTest
# Note: these tests are very incomplete. It is unclear how much of Teem's future
# development will hinge on CTest-based testing, now that the Python/CFFI bindings
# offer a much more convenient way to call into Teem.

if(BUILD_TESTING)
    add_subdirectory(tests/ctest)
endif()

###-------------------------------------------------------------------------------------
# Install rules

# Declare how Teem should be installed, and hang all this off the "TeemTargets" export
# set. This does not copy files immediately; it only registers installation rules, which
# are applied at `cmake --install` time
install(TARGETS Teem
  EXPORT TeemTargets
  LIBRARY DESTINATION ${LIB_INSTALL_DIR}
  ARCHIVE DESTINATION ${LIB_INSTALL_DIR}
  RUNTIME DESTINATION ${BIN_INSTALL_DIR}
  FILE_SET public_headers DESTINATION ${HEADERS_INSTALL_DIR}
)

include(CMakePackageConfigHelpers)

# Generate TeemConfig.cmake from template CMake/TeemConfig.cmake.in.
# We have to do some work to teach Teem to pull in its own dependencies.
# First, build up list of find_dependency() calls for TeemConfig.cmake:
set(_Teem_find_deps "")
foreach(_tdep IN LISTS _Teem_DEPS)
  if(Teem_USE_${_tdep})
    if(NOT _Teem_find_deps)
      # before first dependency, we have to say how to find_dependency()
      string(APPEND _Teem_find_deps "include(CMakeFindDependencyMacro)\n")
    endif()
    # Map to CMake package name
    string(APPEND _Teem_find_deps "find_dependency(${_cpname_${_tdep}} REQUIRED)\n")
  endif()
endforeach()
if(NOT _Teem_find_deps)
  # if, actually, there aren't any dependencies, add a comment saying so
  string(APPEND _Teem_find_deps "# (actually, no dependencies in this Teem build)\n")
endif()
# Then, empower the upcoming configure_package_config_file command to convert
# @Teem_CONFIG_DEPENDENCIES@ (appearing in TeemConfig.cmake.in) to ${_Teem_find_deps}
set(Teem_CONFIG_DEPENDENCIES "${_Teem_find_deps}")
# If we redefined CMAKE_INSTALL_PREFIX (because Teem_INSTALL_VERSIONED_PREFIX was ON),
# record it for TeemConfig.cmake
set(Teem_EFFECTIVE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")
# now finally generate TeemConfig.cmake
configure_package_config_file(
  ${CMAKE_CURRENT_SOURCE_DIR}/CMake/TeemConfig.cmake.in
  ${CMAKE_CURRENT_BINARY_DIR}/TeemConfig.cmake
  INSTALL_DESTINATION ${CONFIG_INSTALL_DIR}
)

# Generate version file (so find_package can check Teem >= X.Y.Z)
write_basic_package_version_file(
  ${CMAKE_CURRENT_BINARY_DIR}/TeemConfigVersion.cmake
  VERSION ${Teem_VERSION_STRING}
  # Teem v2 does have non-zero ABI and API changes from Teem pre-v2, hence the
  # SameMajorVersion instead of AnyNewerVersion below.  Most Teem-using code will likely
  # not need changing to use v2, but it does need to be recompiled.  To honor the
  # expectations of the semantic versioning that Teem adopted in 2005 with version
  # 1.9.0, the major version boundary has to mean something
  COMPATIBILITY SameMajorVersion
)

# Export targets (defined earlier via add_library + install(TARGETS â€¦))
install(EXPORT TeemTargets
  FILE TeemTargets.cmake
  NAMESPACE Teem::
  DESTINATION ${CONFIG_INSTALL_DIR}
)

# Install the package config and version files
install(FILES
  ${CMAKE_CURRENT_BINARY_DIR}/TeemConfig.cmake
  ${CMAKE_CURRENT_BINARY_DIR}/TeemConfigVersion.cmake
  DESTINATION ${CONFIG_INSTALL_DIR}
)
